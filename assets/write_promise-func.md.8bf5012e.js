import{_ as e,o,c as r,a as i}from"./app.40d886d6.js";const _=JSON.parse('{"title":"手写实现 Promise 全部实例方法和静态方法","description":"","frontmatter":{"title":"手写实现 Promise 全部实例方法和静态方法","tags":["promise","手写系列"]},"headers":[{"level":2,"title":"1. 实现 Promise.resolve","slug":"_1-实现-promise-resolve","link":"#_1-实现-promise-resolve","children":[]},{"level":2,"title":"2. 实现 Promise.reject","slug":"_2-实现-promise-reject","link":"#_2-实现-promise-reject","children":[]},{"level":2,"title":"3. 实现 Promise.prototype.catch","slug":"_3-实现-promise-prototype-catch","link":"#_3-实现-promise-prototype-catch","children":[]},{"level":2,"title":"4. 实现 Promise.prototype.finally","slug":"_4-实现-promise-prototype-finally","link":"#_4-实现-promise-prototype-finally","children":[]},{"level":2,"title":"5. 实现 Promise.all","slug":"_5-实现-promise-all","link":"#_5-实现-promise-all","children":[]},{"level":2,"title":"6. 实现 Promise.allSettled","slug":"_6-实现-promise-allsettled","link":"#_6-实现-promise-allsettled","children":[]},{"level":2,"title":"7. 实现 Promise.any","slug":"_7-实现-promise-any","link":"#_7-实现-promise-any","children":[]},{"level":2,"title":"8. 实现 Promise.race","slug":"_8-实现-promise-race","link":"#_8-实现-promise-race","children":[]}],"relativePath":"write/promise-func.md"}'),l={name:"write/promise-func.md"},s=i('<h1 id="手写实现-promise-全部实例方法和静态方法-来看看-promise-all、promise-race-和-promise-any-都是怎么实现的-掘金-juejin-cn" tabindex="-1"><a href="https://juejin.cn/post/7044088065874198536#heading-0" target="_blank" rel="noreferrer">手写实现 Promise 全部实例方法和静态方法，来看看 Promise.all、Promise.race 和 Promise.any 都是怎么实现的 - 掘金 (juejin.cn)</a> <a class="header-anchor" href="#手写实现-promise-全部实例方法和静态方法-来看看-promise-all、promise-race-和-promise-any-都是怎么实现的-掘金-juejin-cn" aria-hidden="true">#</a></h1><h2 id="_1-实现-promise-resolve" tabindex="-1">1. 实现 Promise.resolve <a class="header-anchor" href="#_1-实现-promise-resolve" aria-hidden="true">#</a></h2><p><strong>Promise.resolve(value)</strong> 将给定的一个值转为Promise对象。</p><ul><li>如果这个值是一个 promise ，那么将返回这个 promise ；</li><li>如果这个值是thenable（即带有<code>&quot;then&quot; </code>方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；</li><li>否则返回的promise将以此值完成，即以此值执行<code>resolve()</code>方法 (状态为fulfilled)。</li></ul><h2 id="_2-实现-promise-reject" tabindex="-1">2. 实现 Promise.reject <a class="header-anchor" href="#_2-实现-promise-reject" aria-hidden="true">#</a></h2><p><code>Promise.reject()</code>方法返回一个带有拒绝原因的<code>Promise</code>对象。</p><h2 id="_3-实现-promise-prototype-catch" tabindex="-1">3. 实现 Promise.prototype.catch <a class="header-anchor" href="#_3-实现-promise-prototype-catch" aria-hidden="true">#</a></h2><p><code>catch()</code> 方法返回一个<code>Promise</code>，并且处理拒绝的情况。它的行为与调用<code>Promise.prototype.then(undefined, onRejected)</code> 相同。</p><p>事实上, calling <code>obj.catch(onRejected)</code> 内部calls <code>obj.then(undefined, onRejected)</code>。(这句话的意思是，我们显式使用<code>obj.catch(onRejected)</code>，内部实际调用的是<code>obj.then(undefined, onRejected)</code>)</p><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p><h2 id="_4-实现-promise-prototype-finally" tabindex="-1">4. 实现 Promise.prototype.finally <a class="header-anchor" href="#_4-实现-promise-prototype-finally" aria-hidden="true">#</a></h2><p><code>finally() </code> 方法返回一个<code>Promise</code>。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在<code>Promise</code>是否成功完成后都需要执行的代码提供了一种方式。</p><p>这避免了同样的语句需要在<code>then()</code>和<code>catch()</code>中各写一次的情况。该方法是 ES2018 引入标准的。</p><p><strong>由于无法知道promise的最终状态，所以<code>finally</code>的回调函数中不接收任何参数，它仅用于无论最终结果如何都要执行的情况。</strong></p><h2 id="_5-实现-promise-all" tabindex="-1">5. 实现 Promise.all <a class="header-anchor" href="#_5-实现-promise-all" aria-hidden="true">#</a></h2><p><code>Promise.all()</code> 方法接收一个<code>promise</code>的<code>iterable</code>类型（注：Array，Map，Set都属于ES6的iterable类型）的输入，并且只返回一个<code>Promise</code>实例， 输入的所有<code>promise</code>的<code>resolve</code>回调的结果是一个数组。</p><blockquote><p>返回的这个Promise的resolve回调执行是在所有输入的promise的resolve回调都结束，或者输入的iterable里没有promise了的时候。它的reject回调执行是，只要任何一个输入的promise的reject回调执行或者输入不合法的promise就会立即抛出错误，并且reject的是第一个抛出的错误信息。</p></blockquote><ul><li><code>Promise.all</code> 等待所有都完成（或第一个失败）</li><li>如果传入的参数是一个空的可迭代对象，则返回一个已完成（already resolved）状态的 Promise</li><li>如果参数中包含非 promise 值，这些值将被忽略，但仍然会被放在返回数组中，如果 promise 完成的话 <code>(也就是如果参数里的某值不是Promise，则需要原样返回在数组里)</code></li><li>在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组，它包含所有的传入迭代参数对象的值（也包括非 promise 值）。</li><li>如果传入的 promise 中有一个失败（rejected），Promise.all 异步地将失败的那个结果给失败状态的回调函数，而不管其它 promise 是否完成</li></ul><h2 id="_6-实现-promise-allsettled" tabindex="-1">6. 实现 Promise.allSettled <a class="header-anchor" href="#_6-实现-promise-allsettled" aria-hidden="true">#</a></h2><p>Promise.allSettled(iterable)方法返回一个在所有给定的promise都已经fulfilled或rejected后的promise，并带有一个对象数组，每个对象表示对应的promise结果。</p><ul><li>当你有多个彼此不依赖的异步任务成功完成时，或者你总是想知道每个promise的结果时，通常使用它。</li><li>相比之下，Promise.all() 更适合彼此相互依赖或者在其中任何一个reject时立即结束。</li></ul><p>参数 iterable 是一个可迭代的对象，例如Array，其中每个成员都是Promise。</p><p>对于每个结果对象，都有一个 status 字符串。如果它的值为 fulfilled，则结果对象上存在一个 value 。如果值为 rejected，则存在一个 reason 。value（或 reason ）反映了每个 promise 决议（或拒绝）的值。</p><p><code>Promise.allSettled(iterable)</code> 的参数 iterable 中传入一个非promise值</p><p><strong>Promise.allSettled() 方法内部将非 Promise 值转换成 Promise 了</strong></p><h2 id="_7-实现-promise-any" tabindex="-1">7. 实现 Promise.any <a class="header-anchor" href="#_7-实现-promise-any" aria-hidden="true">#</a></h2><p><strong>本质上，这个方法和Promise.all()是相反的。</strong></p><p><code>Promise.any()</code> 接收一个Promise可迭代对象，只要其中的一个 promise 成功，就返回那个已经成功的 promise 。</p><p>如果可迭代对象中没有一个 promise 成功（即所有的 promises 都失败/拒绝），就返回一个失败的 promise 和<code>AggregateError</code>类型的实例，它是 Error 的一个子类，用于把单一的错误集合在一起。</p><ul><li>如果传入的参数是一个空的可迭代对象，则返回一个 已失败（already rejected） 状态的 Promise。</li><li>如果传入的参数不包含任何 promise，则返回一个 异步完成 （asynchronously resolved）的 Promise。<code>(即将非Promise值，转换为Promise并当做成功)</code></li><li>只要传入的迭代对象中的任何一个 promise 变成成功（resolve）状态，或者其中的所有的 promises 都失败，那么返回的 promise 就会 异步地（当调用栈为空时） 变成成功/失败（resolved/reject）状态。<code>(如果所有Promise都失败，则报错)</code></li></ul><h2 id="_8-实现-promise-race" tabindex="-1">8. 实现 Promise.race <a class="header-anchor" href="#_8-实现-promise-race" aria-hidden="true">#</a></h2><p><code>Promise.race(iterable)</code> 方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。</p><p>一个待定的 Promise 只要给定的迭代中的一个promise解决或拒绝，就采用第一个promise的值作为它的返回值，从而异步地解析或拒绝（一旦堆栈为空）。</p><p><code>race</code> 函数返回一个 <code>Promise</code>，它将与第一个传递的 promise 相同的完成方式被完成。它可以是完成（ resolves），也可以是失败（rejects），这要取决于第一个完成的方式是两个中的哪个。</p><ul><li>如果传的迭代是空的，则返回的 promise 将永远等待。</li><li>如果迭代包含一个或多个非承诺值和/或已解决/拒绝的承诺，则 Promise.race 将解析为迭代中找到的第一个值。</li></ul>',35),a=[s];function t(c,d,p,m,n,h){return o(),r("div",null,a)}const u=e(l,[["render",t]]);export{_ as __pageData,u as default};
